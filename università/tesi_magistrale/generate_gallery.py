import re
import os
import json

html_path = "/Users/emanuelediluzio/Desktop/multimodel_comparison.html"
json_path = "/Users/emanuelediluzio/Desktop/università/tesi_magistrale/visual_benchmark_samples.json"
output_tex = "/Users/emanuelediluzio/Desktop/università/tesi_magistrale/gallery.tex"

# Replaced 12, 22 with 38, 4
target_ids = [11, 13, 16, 17, 24, 25, 38, 4]

sample_titles = {
    11: "Vintage Telephone",
    13: "50 Sign",
    16: "Shopping Cart",
    17: "Sun Icon",
    24: "Shield Icon",
    25: "Tablet with Dollar",
    38: "Complex Geometry",
    4: "Circle with Square"
}

models_of_interest = {
    "Florence-2": "Florence-2",
    "Qwen2-7b": "Qwen2-7B",
    "Llama-8b": "Llama-8B",
    "SPE+Qwen2-7b v2": "SPE+Qwen2-7B",
    "SPE+Gemma-9b v2": "SPE+Gemma-9B"
}

def escape_latex(text):
    if not text:
        return ""
    # Common LaTeX escapes
    chars = {
        "&": "\\&",
        "%": "\\%",
        "$": "\\$",
        "#": "\\#",
        "_": "\\_",
        "{": "\\{",
        "}": "\\}",
        "~": "\\textasciitilde{}",
        "^": "\\textasciicircum{}",
        "\\": "\\textbackslash{}"
    }
    pattern = re.compile('|'.join(re.escape(k) for k in chars.keys()))
    return pattern.sub(lambda m: chars[m.group(0)], str(text))

def load_ground_truth():
    gts = {}
    if not os.path.exists(json_path):
        print(f"JSON not found: {json_path}")
        return gts
    
    try:
        with open(json_path, "r", encoding="utf-8") as f:
            raw_content = f.read()
            start_idx = raw_content.find("{")
            if start_idx == -1:
                print("No JSON object found in file.")
                return gts
            
            clean_content = raw_content[start_idx:]
            data = json.loads(clean_content)

            items = data.get("samples", [])
            print(f"Loaded {len(items)} samples from JSON.")
            for item in items:
                sid = item.get("sample_id")
                try:
                    sid = int(sid)
                except:
                    pass
                
                if sid in target_ids:
                    gts[sid] = item.get("ground_truth_caption", "N/A")
                    print(f"Found GT for {sid}")
    except Exception as e:
        print(f"Error loading JSON: {e}")
    return gts

def parse_html_captions():
    if not os.path.exists(html_path):
        return {}

    with open(html_path, "r", encoding="utf-8") as f:
        content = f.read()

    results = {}
    for tid in target_ids:
        results[tid] = {}
        marker = f'id="sample-{tid}"'
        if marker not in content:
            print(f"Warning: Sample {tid} not found in HTML")
            continue
            
        parts = content.split(marker)
        if len(parts) < 2: 
            continue
            
        sample_block = parts[1].split('id="sample-')[0]
        matches = re.findall(r'<td class="model-name">\s*([^<]+)\s*</td>.*?<div class="caption-text">(.*?)</div>', sample_block, re.DOTALL)
        
        caption_map = {}
        for m_name, c_text in matches:
            m_clean = m_name.strip()
            c_clean = c_text.replace("<br>", "\n").replace("<br/>", "\n").strip()
            c_clean = re.sub(r'\s+', ' ', c_clean)
            caption_map[m_clean] = c_clean
        
        for m_key in models_of_interest.keys():
            results[tid][m_key] = caption_map.get(m_key, "N/A - Model missing in HTML")
            
    return results

def generate_tex(gts, model_caps):
    # Expanded text as requested
    header = r"""
\section{Qualitative Analysis Gallery}
\label{sec:gallery}

This section provides an in-depth qualitative analysis of the model performances by examining eight representative samples from the test set. The selected examples cover a diverse range of visual complexity, spanning from iconic representations and simple geometric patterns to more abstract designs. This variety allows us to observe specific failure modes in baseline models---such as the hallucination of non-existent details or the misinterpretation of spatial relationships---while highlighting the strengths of our proposed SPE-based architectures. For each sample, we present the rendered SVG image alongside the ground truth caption and the varying descriptions generated by Florence-2, Qwen2-7B, Llama-3-8B, and our fine-tuned SPE variants (SPE+Qwen2 and SPE+Gemma). This side-by-side comparison offers tangible insight into how different architectures perceive and textualize vector graphics.
"""
    
    body = ""
    
    for tid in target_ids:
        title = sample_titles.get(tid, f"Sample {tid}")
        img_path = f"images/gallery/sample_{tid}.png"
        
        gt_text = escape_latex(gts.get(tid, "(Ground Truth not available)"))
        
        desc_items = ""
        desc_items += f"        \\item[\\textbf{{Ground Truth}}:] {gt_text}\n"
        
        caps = model_caps.get(tid, {})
        for m_key, m_display in models_of_interest.items():
            raw_text = caps.get(m_key, "N/A")
            safe_text = escape_latex(raw_text)
            desc_items += f"        \\item[\\textbf{{{m_display}}}:] {safe_text}\n"
            
        # Compact layout settings
        figure_block = f"""
\\begin{{figure}}[!ht]
    \\centering
    \\includegraphics[width=0.25\\textwidth]{{{img_path}}}
    \\caption*{{Sample {tid}: {title}}}
    \\vspace{{-1.0em}}
    \\scriptsize
    \\setlength{{\\itemsep}}{{0pt}}
    \\setlength{{\\parskip}}{{0pt}}
    \\begin{{description}}
{desc_items}    \\end{{description}}
    \\label{{fig:sample{tid}_detail}}
\\end{{figure}}
"""
        body += figure_block
        
    full_content = header + body
    
    with open(output_tex, "w", encoding="utf-8") as f:
        f.write(full_content)
    print(f"Generated {output_tex}")

def main():
    print("Loading Ground Truths...")
    gts = load_ground_truth()
    
    print("Loading Model Captions...")
    model_caps = parse_html_captions()
    
    print("Generating LaTeX...")
    generate_tex(gts, model_caps)
    print("Done.")

if __name__ == "__main__":
    main()
